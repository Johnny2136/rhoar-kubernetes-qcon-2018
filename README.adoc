= Reactive Microservices on Kubernetes: Using Red Hat OpenShift Application Runtimes
Deven Phillips <deven.phillips@redhat.com>
v1.0, 2018-05-22
:conum-guard-java: //
ifndef::icons[:conum-guard-java: // //]
:conum-guard-groovy: //
ifndef::icons[:conum-guard-groovy: // //]

== Overview
Microservices and Containers have changed the entire landscape of software
development in the last few years. We are now able to decompose our development
work into smaller and more digestible components which are easier to understand
and easier to split amongst developer teams for better parallel workflow.

Just as Linux has pretty much won the hearts and minds of most developers
for the operating system of the cloud, Kubernetes has become the de-facto
standard for orchestrating containers at scale.

In this workshop, you will learn how to leverage Containers and Kubernetes
to build a productive DevOps workflow using Kubernetes (Wrapped by OpenShift)
to build, test, deploy, and validate microservices quickly and reliably.

Some of the tools we will leverage in this workshop are listed below:

* https://kubernetes.io/[Kubernetes] (In the form of OpenShift Container Platform 3.9)
* https://jenkins.io/[Jenkins] (For continuous integration and continuous delivery)
* https://www.sonarqube.org/[SonarQube] (For code quality analysis)
* https://www.sonatype.com/nexus-repository-sonatype[Sonatype Nexus] (For an artifact repository)
* https://www.owasp.org/index.php/OWASP_Zed_Attack_Proxy_Project[OWASP Zed Attack Proxy] (For security analysis of web applications)
* https://www.owasp.org/index.php/OWASP_Dependency_Check[OWASP Dependency Check]
* http://vertx.io/[Vert.x] - A toolkit for developing reactive applications on the JVM
* http://openjdk.org/[Java] - A modern and high-performance programming language
* http://spockframework.org/spock/docs/1.1/index.html[Spock Framework] A testing and specification framework for Java and Groovy applications
* https://nodejs.org/[Node.js] - A programming language well suited to quickly develop applications
* https://projects.spring.io/spring-boot/[Spring Boot] An alternative to writing applications using JavaEE
* https://hoverfly.readthedocs.io/en/latest/[HoverFly] A service virtualization tool which simplifies testing Microservices

== What we are going to do during today's workshop

. <<#section-1,▼>> Load up a complete DevOps environment in Kubernetes using Ansible automation
. <<#section-2,▼>> Load our existing application code into this DevOps environment and wire it up to our GitHub repos
. <<#section-3,▼>> Create a Vert.x microservice project to work with these existing services and communicate with each other
.. <<#section-3-a,▼>> Set Up For Testing
.. <<#section-3-b,▼>> Familiarize ourselves with some basic Vert.x concepts
.. <<#section-3-c,▼>> Implement Vert.x Kubernetes Config
.. <<#section-3-d,▼>> Implement clients for the noun and adjective services using OpenAPI specifications
.. <<#section-3-e,▼>> Implement a REST API using OpenAPI 3 specifications and service proxies
.. <<#section-3-f,▼>>Implement a new https://vertx.io/docs/vertx-service-proxy/java/[service proxy]
.. <<#section-3-g,▼>>Implement a reactive Kafka system to stream "liked" insults
.. <<#section-3-h,▼>>Generate JavaScript code to integrate our application into the UI
.. <<#section-3-i,▼>>Implement circuit breakers to prevent poor user experience
.. <<#section-3-j,▼>>Implement some BDD tests for our service
. <<#section-4-b,▼>>Run our application code through the DevOps pipeline and resolve issues QUICKLY!
. <<#section-5-b,▼>>Perform code quality analysis and unit/integration testing using SonarQube and HoverFly
. <<#section-6-b,▼>>Analyze our web application for security vulnerabilities using OWASP Zed Attack Proxy
. <<#section-7-b,▼>>Analyze our the library dependencies of our services to check for vulnerable libraries

=== [[section-3]] Create a new Vert.x project
. Ensure that you have Apache Maven >= 3.3.9
. From the `insult-service` directory, run the following command

.Executing Fabric8 Vert.x Plugin To Start A New Project
[source,bash]
----
$ mvn io.fabric8:vertx-maven-plugin:1.0.13:setup -DvertxVersion=3.5.1
[INFO] Scanning for projects...
[INFO] 
[INFO] ------------------------------------------------------------------------
[INFO] Building Maven Stub Project (No POM) 1
[INFO] ------------------------------------------------------------------------
[INFO] 
[INFO] --- vertx-maven-plugin:1.0.13:setup (default-cli) @ standalone-pom ---
[INFO] No pom.xml found, creating it in /home/dphillips/Documents/RedHat/Workspace/rhoar-kubernetes-qcon-2018/insult-service
Set the project groupId [io.vertx.example]: com.redhat.qcon
Set the project artifactId [my-vertx-project]: insult-service
Set the project version [1.0-SNAPSHOT]: 1.0.0-SNAPSHOT
Set the vertcile class name [com.redhat.qcon.MainVerticle]: 
[INFO] Creating verticle com.redhat.qcon.MainVerticle
[INFO] Creating directory /home/dphillips/Documents/RedHat/Workspace/rhoar-kubernetes-qcon-2018/insult-service/src/main/java/com/redhat/qcon
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
[INFO] ------------------------------------------------------------------------
[INFO] Total time: 34.510 s
[INFO] Finished at: 2018-05-21T12:07:46-04:00
[INFO] Final Memory: 9M/166M
[INFO] ------------------------------------------------------------------------
----

This will create a new Maven POM file populated based on the values you entered during the setup.

After the POM file has been created, we will need to add some additional libraries for this microservice:

* vertx-web-api-contract
* vertx-rx-java2
* vertx-service-proxy
* vertx-sockjs-service-proxy
* vertx-config-kubernetes-configmap
* vertx-codegen
* vertx-lang-js

All of these are within the `io.vertx` Maven group ID and covered via the depenency management setup 
from the initialization process, so we can put them in without versions as follows:

.POM Excerpt Showing Provided and Processor Dependencies
[source,xml,subs=attributes+]
----
<dependency>
    <groupId>io.vertx</groupId>
    <artifactId>vertx-web-api-contract</artifactId>
</dependency>
<dependency>
    <groupId>io.vertx</groupId>
    <artifactId>vertx-rx-java2</artifactId>
</dependency>
<dependency>
    <groupId>io.vertx</groupId>
    <artifactId>vertx-service-proxy</artifactId>
</dependency>
<dependency>
    <groupId>io.vertx</groupId>
    <artifactId>vertx-sockjs-service-proxy</artifactId>
</dependency>
<dependency>
    <groupId>io.vertx</groupId>
    <artifactId>vertx-config-kubernetes-configmap</artifactId>
</dependency>
<dependency>
    <groupId>io.vertx</groupId>
    <artifactId>vertx-codegen</artifactId>
    <scope>provided</scope>
    <classifier>processor</classifier>
</dependency>
<dependency>
    <groupId>io.vertx</groupId>
    <artifactId>vertx-lang-js</artifactId>
    <scope>provided</scope>
</dependency>
----

=== [[section-3-a]] Set Up For Testing

Vert.x comes with a JUnit-compatible library for doing unit testing called `vertx-unit`. Personally,
I prefer BDD style tests, so for this workshop I will be demonstrating 
http://spockframework.org/spock/docs/1.1/index.html[SpockFramework]. To use Spock, we will need to
add some additional dependencies to our POM:

.Adding Libraries For Spock Framework and Code Coverage
[source,xml,subs=attributes+]
----
<dependency>
    <groupId>org.codehaus.groovy</groupId>
    <artifactId>groovy-all</artifactId>
    <version>2.4.12</version>
    <scope>test</scope>
</dependency>
<dependency>
    <groupId>org.javassist</groupId>
    <artifactId>javassist</artifactId>
    <version>3.21.0-GA</version>
    <scope>test</scope>
</dependency>
<dependency>
    <groupId>org.spockframework</groupId>
    <artifactId>spock-core</artifactId>
    <version>1.1-groovy-2.4</version>
    <scope>test</scope>
</dependency>
<dependency>
    <groupId>net.bytebuddy</groupId>
    <artifactId>byte-buddy</artifactId>
    <version>1.7.5</version>
    <scope>test</scope>
</dependency>
<dependency> <!-- enables mocking of classes without default constructor (together with CGLIB) -->
    <groupId>org.objenesis</groupId>
    <artifactId>objenesis</artifactId>
    <version>2.6</version>
    <scope>test</scope>
</dependency>
----

We will also need to add the GMavenPlus plugin and configure the Maven SureFire plugin to be able to
run the Spock tests:

.Add Maven Plugins For Spock Framework and Code Coverage
[source,xml,subs=attributes+]
----
<build>
    <plugins>
    ... SNIP ...
        <plugin>    <!-- Add support for compiling Groovy files -->
            <groupId>org.codehaus.gmavenplus</groupId>
            <artifactId>gmavenplus-plugin</artifactId>
            <version>1.5</version>
            <executions>
                <execution>
                    <goals>
                        <goal>addSources</goal>
                        <goal>addTestSources</goal>
                        <goal>generateStubs</goal>
                        <goal>compile</goal>
                        <goal>testGenerateStubs</goal>
                        <goal>testCompile</goal>
                        <goal>removeStubs</goal>
                        <goal>removeTestStubs</goal>
                    </goals>
                </execution>
            </executions>
        </plugin>
        <plugin>    <!-- Configure the Maven SureFire plugin to use Groovy Spec files for test -->
            <artifactId>maven-surefire-plugin</artifactId>
            <version>2.6</version>
            <configuration>
                <useFile>false</useFile>
                <includes>
                    <include>**/*Spec.groovy</include>
                </includes>
            </configuration>
        </plugin>
        <plugin>    <!-- Configure JaCoCo to be able to extract code coverage information -->
            <groupId>org.jacoco</groupId>
            <artifactId>jacoco-maven-plugin</artifactId>
            <version>0.7.6.201602180812</version>
            <executions>
                <execution>
                    <id>jacoco-initialize</id>
                    <goals>
                        <goal>prepare-agent</goal>
                    </goals>
                </execution>
                <execution>
                    <id>jacoco-site</id>
                    <phase>test</phase>
                    <goals>
                        <goal>report</goal>
                    </goals>
                </execution>
            </executions>
        </plugin>
    ... SNIP ...
    </plugins>
</build>
----

=== [[section-3-b]] Basic Vert.x Concepts

The https://vertx.io/docs/vertx-core/java/[Vert.x Core Documentation] is a really great reference to some of the basic
concepts in Vert.x. We'll cover a few of these things here, but please feel free to go to the official docs for more
in-depth information.

Vert.x implements a *fluent* SPI. This means that for most Vert.x components, you can chain calls together in a nicely
readable manner.

[source,java,subs=attributes+]
----
vertx.eventBus()
     .consumer("some-address")
     .toObservable()
     .doOnError(this::errorHandler)
     .subscribe(this::messageHandler);
----

Another core concept of Vert.x is that everything which is done in a Verticle should be done in a non-blocking way. 
To support this, Vert.x provides non-blocking implementations of many common functionalities such as:

* File I/O
* Network I/O
* Database Access
* Message Queues
* HTTP Clients/Servers
* Authentication/Authorization/Audit (AAA)
* Metrics

==== Verticles
From the new project we generated via Maven, we can see that a class called `MainVerticle` was created. 
https://vertx.io/docs/vertx-core/java/#_verticles[Verticles] are the basic unit of an application in Vert.x. By default,
Verticles are run single-threaded on an event loop (Reactor Pattern). The one difference between this and other Reactor 
Pattern implementations you may have seen before is that Vert.x runs MULTIPLE event loops in parallel, calling it 
https://vertx.io/docs/vertx-core/java/#_reactor_and_multi_reactor[Multi-Reactor].

The basic contents of a Vertical are a class definition and a `start` method, as shown here:

[source,java,subs=attributes+]
----
package com.redhat.qcon;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Future;

public class MainVerticle extends AbstractVerticle {

    @Override
    public void start(Future<Void> startFuture) {
        startFuture.complete(); // Called once the Vertical is ready
    }
}
----

==== Non-Blocking
Because Vert.x uses event loops for Verticles, we must always ensure that we do not call blocking code and thus block
the event loop. Since Vert.x does not have non-blocking APIs for every situation, it provides a method of
implementing traditional blocking Java code using the `vertx.executeBlocking` method. For example, if we wanted to make a
call via http://www.oracle.com/technetwork/java/jndi/index.html[JNDI] to look up something in an LDAP directory, we
might do something like:

[source,java,subs=attributes+]
----
vertx.executeBlocking(future -> {
    // Make our JNDI calls here!
    future.complete(result);
}, result -> {
    // Handle the results of the blocking operation once it completes.
});
----

==== [[section-3-b-eventbus]] Event Bus
The final concept we should introduce for Vert.x is the Event Bus. Since all of the Verticles are implemented to 
run single-threaded and potentially across multiple threads/cores in parallel, we need a safe way to share data which
will not cause race conditions or concurrency problems. To facilitate this, Vert.x has an Event Bus through which we
can send/receive messages between Verticles. A simple example of using the event bus might look like:

[source,java,subs=attributes+]
----
// Create a consumer and reply when we get PING messages
vertx.eventBus()
    .consumer("ping-timer")
    .toFlowable()
    .doOnEach(m -> System.out.println(m.getValue().body()))
    .subscribe(m -> m.reply(new JsonObject().put("action", "PONG")));

// Set a period timer to send a "PING" message every 300 milliseconds
vertx.timerStream(300)
    .toObservable()
    .map(t -> new JsonObject().put("action", "PING"))
    .subscribe(ping -> vertx.eventBus()
            .rxSend("ping-timer", ping)
            .subscribe(m -> System.out.println(m.body())));
----

=== [[section-3-c]] Implement Kubernetes Config
Following one of the tenets of https://12factor.net/config[12 Factor Applications], we will want to store our
application's configuration in the deployment environment instead of in our code. Vert.x makes this somewhat painless
by providing a comprehensive set of APIs for loading the application's configuration. In our case, since we are
deploying to Kubernetes, we will use Kubernetes ConfigMaps for our configuration. 

Another best practice is that we should practice "test first" development. To further that concept, let's start
by writing a failing test for the feature we intent to implement.

.src/test/groovy/com/redhat/qcon/MainVerticleSpec.groovy
[source,groovy,subs=attributes+]
----
package com.redhat.qcon

import io.vertx.core.Future
import io.vertx.core.Vertx
import spock.lang.Specification
import spock.util.concurrent.AsyncConditions

class MainVerticleSpec extends Specification {

    def 'Test Vert.x configuration loading'() {
        given: 'An instance of Vert.x'  {conum-guard-groovy} <1>
            def vertx = Vertx.vertx()
        and: 'An instance of a Vert.x Future'  {conum-guard-groovy} <2>
            def fut = Future.future()
        and: '''An instance of Spock's AsyncConditions''' {conum-guard-groovy} <3>
            def async = new AsyncConditions(1)

        when: 'We attempt to deploy the main Verticle'  {conum-guard-groovy} <4>
            vertx.deployVerticle(new MainVerticle(), fut.completer())

        then: 'Expect that the correct configuration is found and loaded'
            fut.setHandler({ res ->
                async.evaluate { {conum-guard-groovy} <5>
                    res.succeeded() {conum-guard-groovy} <6>
                    vertx.getOrCreateContext().config().hasProperty('noun') {conum-guard-groovy} <7>
                    vertx.getOrCreateContext().config().hasProperty('adjective') {conum-guard-groovy} <8>
                    vertx.getOrCreateContext().config().hasProperty('http') {conum-guard-groovy} <9>
                }
            })

        cleanup: 'Await the async operations'  {conum-guard-groovy} <10>
            async.await(10)
    }
}
----
<1> Set our starting conditions. In this case, we need a running Vert.x instance
<2> Using the `and` block, we can specify additional `given`, `when`, or `then` conditions
<3> Use the `when` block to call the code under test
<4> The `AsyncConditions` class is provided by Spock to allow us to check for one or more asynchronous events
<5> Use the `async.evaluate` to tell Spock that we are waiting for an asynchronous operation
<6> Check to ensure that the future completed successfully
<7> Check to ensure that the config contains a `noun` property
<8> Check to ensure that the config contains a `adjective` property
<9> Check to ensure that the config contains a `http` property
<10> Tell Spock to wait `10` seconds for the async operations to complete

Spock tests are written using a format known as Gherkin. Gherkin formats tests as given-when-then. Spock also has
a format for writing data-driven tests which we will use and explain later.

Now that we have written our test, here's how I would implement the feature code.

.Implementing Kubernetes ConfigMap Support
[source,java,subs=attributes+]
----
package com.redhat.qcon;

import io.reactivex.Single;
import io.vertx.config.ConfigRetrieverOptions;
import io.vertx.config.ConfigStoreOptions;
import io.vertx.core.Future;
import io.vertx.core.json.JsonObject;
import io.vertx.reactivex.config.ConfigRetriever;
import io.vertx.reactivex.core.AbstractVerticle;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class MainVerticle extends AbstractVerticle {

    private static final Logger LOG = LoggerFactory.getLogger(MainVerticle.class);

    Single<JsonObject> initConfigRetriever() {                                  {conum-guard-groovy} <1>
        // Load the default configuration from the classpath
        LOG.info("Configuration store loading.");
        ConfigStoreOptions defaultOpts = new ConfigStoreOptions()               {conum-guard-groovy} <2>
                .setType("file")
                .setFormat("json")
                .setConfig(new JsonObject().put("path", "insult_default_config.json"));

        // Load container specific configuration from a specific file path inside of the container
        ConfigStoreOptions localConfig = new ConfigStoreOptions()               {conum-guard-groovy} <3>
                .setType("file")
                .setFormat("json")
                .setConfig(new JsonObject().put("path", "/opt/docker_config.json"))
                .setOptional(true);

        // When running inside of Kubernetes, configure the application to also load from a ConfigMap
        ConfigStoreOptions confOpts = new ConfigStoreOptions()                  {conum-guard-groovy} <4>
                .setType("configmap")
                .setConfig(new JsonObject()
                        .put("name", "insult-config")
                        .put("optional", true)
                );

        // Add the default and container config options into the ConfigRetriever
        ConfigRetrieverOptions retrieverOptions = new ConfigRetrieverOptions()  {conum-guard-groovy} <5>
                .addStore(defaultOpts)
                .addStore(localConfig)
                .addStore(confOpts);

        // Create the ConfigRetriever and return the Maybe when complete
        return ConfigRetriever.create(vertx, retrieverOptions).rxGetConfig();   {conum-guard-groovy} <6>
    }

    @Override
    public void start(Future<Void> startFuture) {

        initConfigRetriever()                                                   {conum-guard-groovy} <7>
                .doOnError(startFuture::fail)                                   {conum-guard-groovy} <8>
                .subscribe(c -> {
                    LOG.info(c.encodePrettily());
                    context.config().mergeIn(c);                                {conum-guard-groovy} <9>
                    startFuture.complete();                                     {conum-guard-groovy} <10>
                });
    }
}
----
<1> Define a new method which returns a `Single` with the configuration
<2> Create an instance of `ConfigStoreOptions` to load the default config from the classpath
<3> Create an instance of `ConfigStoreOptions` to load configuration data from inside a Docker container
<4> Create an instance of `ConfigStoreOptions` to load configuration data from Kubernetes ConfigMaps
<5> Attach the `ConfigStoreOptions` to the `ConfigRetrieverOptions`
<6> Return the RxJava2 `Single` which may be completed at a later time
<7> From inside of the `start` method, call `initConfigRetriever`
<8> Set an error handler for the `Single` which will fail the Verticle deployment when an error is encountered
<9> Merge the loaded configuration into the global Vert.x configuration
<10> Complete the `startFuture` successfully

This example replaces the generic Verticle type with one which has been refactored to use
Reactive Extensions. Most of the rest of this Workshop with rely on using ReactiveX for 
our Vert.x code.

[NOTE]
====
When using the Vert.x ConfigStoreOptions, remember that the order in which ConfigStoreOptions are added
is significant. Items added later will override values from items which were loaded earlier. For example, if the
default config sets `noun.host = 'localhost'`, but the Kubernetes ConfigMap sets `noun.host = '192.168.1.10'`,
the ConfigMap value will take precedence.
====

[NOTE]
====
The single Spock test which we wrote allows us to achieve 100% line AND branch coverage without using ANY dependency
injection because it is a limited form of integration test. Admittedly, the test does not test the Kubernetes ConfigMap
unless it is run inside of Kubernetes/OpenShift, but that would violate the rule of *_Don't test the framework, only test
your code_*. Keep in mind that *I am NOT advocating for 100% coverage*, as that leads to spending a lot of
time and resources for little gain. You should, however, aim to cover all critical paths in your tests.
====

=== Implement a new https://vertx.io/docs/vertx-service-proxy/java/[Service Proxy]
Vert.x provides a facility to make it easier to consume/produce messages on the Event Bus. In the first 
<<#section-3-b-eventbus,example>> of sending and receiving on the event bus, we used a producer and a consumer based on
rx-java2. Setting each of these various endpoints can become tedious and does not provide the best developer
experience. Instead, we can use Vert.x Service Proxies to provide an easier way to implement business logic
and then expose that business logic on the event bus in a more consumable manner.

==== The Interface
All service proxies start with an Interface definition which looks something like this:

.src/main/java/com/redhat/qcon/services/NounService.java
[source,java,subs=attributes+]
----
package com.redhat.qcon.services.noun;

import io.vertx.codegen.annotations.ProxyGen;
import io.vertx.codegen.annotations.VertxGen;
import io.vertx.core.AsyncResult;
import io.vertx.core.Handler;
import io.vertx.core.Vertx;
import io.vertx.core.json.JsonObject;

@ProxyGen
@VertxGen
public interface NounService {

    static NounService create(Vertx vertx) {
        return new NounServiceImpl(vertx);
    }

    static NounService createProxy(Vertx vertx, String address) {
        return new NounServiceVertxEBProxy(vertx, address);
    }

    // Business logic methods here!!

    void get(Handler<AsyncResult<JsonObject>> nounGetHandler);

    void save(String noun, Handler<AsyncResult<JsonObject>> nounSaveHandler);

    @Fluent
    NounService healthCheck(Handler<AsyncResult<Boolean>> nounHealthCheckHandler);
}
----

All of the business logic methods return "void" or the can be fluent and return their service instance.
The two static methods at the beginning are boilerplate for Service Proxies. These methods are used
by the underlying runtime to provide a simple means of wiring up the service proxy.

[NOTE]
====
The business logic methods do not have an access modifier set (e.g. public/private/protected). This means that it
defaults to *_package private_*. By doing this, when we implement unit/BDD tests with Spock we can call those methods
directly.
====

Now that we have an interface, we need to create a series of tests for that code:

.src/test/groovy/com/redhat/qcon/services/NounServiceImplSpec.groovy
[source,java,subs=attributes+]
----

----

.src/main/java/com/redhat/qcon/services/noun/NounService.java
[source,java,subs=attributes+]
----
package com.redhat.qcon.services.noun;

import io.vertx.core.AsyncResult;
import io.vertx.core.Handler;
import io.vertx.core.Vertx;
import io.vertx.core.json.JsonObject;

public class NounServiceImpl implements NounService {

    Vertx vertx;

    public NounServiceImpl(Vertx vertx) {
        this.vertx = vertx;
    }

    @Override
    public void get(Handler<AsyncResult<JsonObject>> nounGetHandler) {

    }

    @Override
    public void save(String noun, Handler<AsyncResult<JsonObject>> nounSaveHandler) {

    }

    @Override
    public NounService healthCheck(Handler<AsyncResult<Boolean>> nounHealthCheckHandler) {
        return this;
    }
}
----

And finally, we must create a `package-info.java` file annotated with `@ModuleGen` in order for the
Vert.x annotation processor to work.

[source,java,subs=attributes+]
----
@ModuleGen(name = "insult", groupPackage = "com.redhat.qcon.services")
package com.redhat.qcon;

import io.vertx.codegen.annotations.ModuleGen;
----

We have left the service implementation class as a stub so that we can delve deeper into HTTP clients
in the next section.

=== Implement REST clients
Vert.x recently introduced significant support for the https://www.openapis.org/[OpenAPI v3 Specification] language. 
OpenAPI 3 allows us to describe a REST API using YAML or JSON. From those specifications, we can create both server
and client implementations for the REST API. We will use this facility in Vert.x to create REST API clients for the
Noun and Adjective services which were previously implemented using NodeJS and Spring Boot. Here's how:

1. Create a new class 

=== Implement REST API
==== TODO: Using OpenAPI 3 Spec file to create REST API in Vert.x
